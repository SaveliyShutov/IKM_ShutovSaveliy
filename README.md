# Итоговая контрольная работа Шутов С.А ит-5 Вариант 2

Постановка задачи
	Игра в слова. Дан набор слов. Известно, что эти слова использовались для игры, в которой очередное слово должно заканчиваться той буквой, на которую закончилось предыдущее слово. С какого слова начинается игра, не имеет значения. Если слово оканчивается на «ь», то используется предыдущая буква. Последнее слово цепочки должно заканчиваться буквой первого слова цепочки. Входной файл содержит все слова в одной строке, слова записаны строчными буквами русского алфавита, между словами может быть один или более пробелов. Требуется выстроить данные слова в цепочку согласно правилам игры. Достаточно найти одно подходящее решение. Возможен вариант, что решений не существует. 
Алгоритм решения
1. Постановка задачи
 	Дан набор слов, изначально записанных в одну строку через пробелы. Требуется упорядочить их в «цепочку» так, чтобы каждое последующее слово начиналось на ту букву, на которую окончится предыдущее. Если слово оканчивается на мягкий знак «ь», считается пред­последняя буква. Начать можно с любого слова, но при этом последнее слово должно заканчиваться на первую букву первого. Если такого порядка не существует, сообщить об этом.
2. Ключевая идея
 – Каждое слово представляем как ориентированное ребро: из вершины-буквы, равной первой букве, в вершину-букву, равную последнему значимому символу.
 – Задача превращается в поиск цикла, проходящего по всем рёбрам ровно один раз (эйлеров цикл).
 – На практике, поскольку граф небольшой, достаточно выполнить глубинный поиск (DFS) с учётом использованных слов и вернуть первую найденную замкнутую последовательность.
3. Подробный алгоритм
    1. Разбор входных данных

        ◦ Считываем строку, разбиваем по пробелам, фильтруем пустые токены.

        ◦ Проверяем: есть ли хотя бы одно слово.

    2. Определение значимых букв

        ◦ Для каждого слова w:

            1. start = w[0]

            2. end = w[-2], если w.endswith('ь') и len(w)>1, иначе w[-1].

    3. Построение графа

        ◦ Создать словарь смежности graph: Dict[буква] → List[(буква, слово)].

        ◦ Для каждого слова добавить в graph[start].append((end, слово)).

    4. Поиск цепочки (DFS + бэктрекинг)

        ◦ Для каждой вершины-начальной буквы или прямо для каждого слова:

            1. Завести пустые структуры:

                • used_words — множество уже помещённых в цепочку слов.

                • current_path — список слов в порядке обхода.

            2. Рекурсивная функция search(word):

                • Добавить word в current_path и used_words.

                • Если len(current_path) == total_words:

                    1. Проверить, совпадает ли конец последнего слова с началом первого (end(current_path[-1]) == start(current_path[0])).

                    2. Если да → решение найдено. Иначе — откатиться.

                • Иначе:

                    1. Вычислить last_letter текущего word.

                    2. Перебрать все (next_letter, next_word) в graph[last_letter].

                    3. Для каждого next_word, не входящего в used_words, вызвать search(next_word).

                        ▪ Если вложенный вызов вернул успех → сразу вернуть успех.

                • Если ни один путь не привёл к успеху → удалить word из used_words и current_path (откат) и вернуть неуспех.

        ◦ Запустить search(initial_word) для каждого initial_word из списка.
4. Сложность
    • Временная: в худшем случае при полном переборе путей DFS получается экспоненциальная сложность, примерно O(k·n!), где n — количество слов, k — среднее число вариантов продолжения на каждом шаге. На практике для n≲15 алгоритм работает быстро, поскольку большая часть ветвей отсеивается при проверке использованных слов и замкнутости цикла.

    • Память: O(n) для хранения графа и O(d) дополнительной памяти на рекурсивный стек (где d ≤ n — глубина поиска, равная длине пути).
5. Итог
 Алгоритм для «Игры в слова» использует только примитивные операции языка (строки, списки, множества, простая арифметика индексов) и собственные структуры данных (словарь для графа и рекурсивный вызов вместо сторонних библиотек). Решение универсально, его легко обосновать через инвариант DFS: на каждом шаге текущий путь корректен и не содержит повторений, а проверка замкнутости гарантирует выполнение условий задачи.
