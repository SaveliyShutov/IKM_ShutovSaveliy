# Итоговая контрольная работа Шутов С.А ит-5 Вариант 2

## 1. Постановка задачи

Программа принимает произвольную последовательность слов и пытается построить **замкнутую словесную цепочку**:

* каждое следующее слово начинается с буквы, на которую оканчивается предыдущее (мягкий знак `ь` в конце игнорируется);
* последний элемент начинается с первой буквы первого слова;
* каждое исходное слово используется **ровно один раз**; одноимённые слова различаются по позиции во входном списке.
  Если цепочка существует, программа выводит её, иначе сообщает, что построение невозможно.

---

## 2. Выбор структуры данных и обоснование

| Задача                                | Структура                          | Почему именно она                                                                         |
| ------------------------------------- | ---------------------------------- | ----------------------------------------------------------------------------------------- |
| Хранение исходных слов                | `list[str]`                        | Сохраняет порядок, индекс служит уникальным идентификатором слова.                        |
| Представление переходов «буква→слово» | `dict[str, list[tuple[str, int]]]` | Доступ по первой букве за `O(1)`; список хранит все рёбра (целевую букву и индекс слова). |
| Отслеживание уже использованных слов  | `set[int]`                         | Проверка принадлежности к множеству — `O(1)` в процессе DFS.                              |

Граф ориентированный, так как направление «первая → последняя буква» важно. В рёбрах хранится индекс слова, чтобы различать одинаковые строки.

---

## 3. Алгоритм решения

1. **Парсинг ввода**: фильтрация токенов `isalpha()` → `words`.
2. **Построение графа** `buildGraph()`.
3. **Поиск цепочки** — рекурсивный DFS‑бэктрекинг `searchChain`:

   1. Перебираем каждый индекс как старт.
   2. Во время обхода помечаем использованные индексы.
   3. При глубине `N` (число слов) проверяем, что последняя буква совпадает с первой. Если да — найден замкнутый цикл.
4. **Формирование результата**: собираем слова по найденному пути или выводим, что цепочка невозможна.

Сложность поиска — `O(N!)` в худшем случае (полный перебор перестановок); практическая производительность достигается за счёт раннего отсеивания неподходящих путей.

---

## 4. Обработка исключений

| Где                    | Исключение          | Обоснование                                                          |
| ---------------------- | ------------------- | -------------------------------------------------------------------- |
| `__init__`             | `ValueError`        | Останавливает создание объекта при отсутствии допустимых слов.       |
| `main()` (пустой ввод) | `ValueError`        | Предупреждает пользователя о пустом вводе до создания объекта.       |

---

## 5. Используемые принципы ООП

| Принцип                  | Реализация в коде                                                                 | Для чего                                                                                                                                                    |
| ------------------------ | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Класс                    | `WordChainGame`                                                                   | Инкапсулирует данные (слова, граф) и поведение (методы) путём создания единого объекта.                                                                     |
| Инкапсуляция             | Внутренняя логика спрятана в методах `buildGraph`, `searchChain`, `getLastLetter` | Снижает связанность; внешний пользователь обращается только к `findChain()`.                                                                                |
| Наследование/полиморфизм | Не требуется в текущей задаче                                                     | Функциональность сосредоточена в одном классе. При расширении (например, поддержка других алфавитов) достаточно унаследовать класс и переопределить методы. |
